# Creating Image Publisher Node 
---

### **Step 1: Create the Image Processing Node Script**

1. **Navigate to Your Package Directory**:
   - Move into the package directory where you'll create the script:

   ```bash
   cd ~/ros2_ws/src/system/system
   ```

2. **Create a Python Script**:
   - Inside the `system` directory, create a new directory called `scripts` if it doesnâ€™t exist, and then create a Python script named `publisher.py`:

   ```bash
   mkdir scripts
   cd scripts
   touch publisher.py
   ```

3. **Write the Image Publishing Script**:
   - Open the `publisher.py` file with your preferred text editor:

   ```bash
   gedit publisher.py
   ```

   **_*Note_**: If gedit is not installed, install it by running `sudo apt install gedit`.
   
   - Add the following code to the script:

   ```python
   # PUBLISHER NODE
   
   import paho.mqtt.client as mqtt
   import rclpy
   from rclpy.node import Node
   from sensor_msgs.msg import Image
   from cv_bridge import CvBridge
   from datetime import datetime
   import numpy as np
   import cv2
   
   BROKER_ADDRESS = "localhost"
   MQTT_TOPIC = "camera/images"
   ROS_TOPIC = "image_topic"
   
   class MqttToRosPublisher(Node):
       def __init__(self):
           super().__init__('mqtt_to_ros_publisher')
           self.publisher_ = self.create_publisher(Image, ROS_TOPIC, 10)
           self.bridge = CvBridge()
   
           self.mqtt_client = mqtt.Client()
           self.mqtt_client.on_message = self.on_message
           self.mqtt_client.connect(BROKER_ADDRESS, 1883, 60)
           self.mqtt_client.subscribe(MQTT_TOPIC)
           self.mqtt_client.loop_start()
           self.get_logger().info(f"Subscribed to MQTT topic: {MQTT_TOPIC}")
   
   
       def on_message(self, client, userdata, msg):
           self.get_logger().info(f"Image received from MQTT topic: {MQTT_TOPIC}")
   
           image_data = msg.payload
           timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
   
           try:
               np_arr = np.frombuffer(image_data, np.uint8)
               cv_image = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)
   
               ros_image = self.bridge.cv2_to_imgmsg(cv_image, encoding="bgr8")
               ros_image.header.frame_id = f"mqtt_image_{timestamp}"
   
               self.publisher_.publish(ros_image)
               self.get_logger().info(f"Published image to ROS topic: {ROS_TOPIC}")
   
           except Exception as e:
               self.get_logger().error(f"Failed to process or publish image: {e}")
   
   def main(args=None):
       rclpy.init(args=args)
       mqtt_to_ros_publisher = MqttToRosPublisher()
       rclpy.spin(mqtt_to_ros_publisher)
       mqtt_to_ros_publisher.destroy_node()
       rclpy.shutdown()
   
   if __name__ == "__main__":
       main()
   ```

5. **Make the Script Executable**:
   - After saving the file, make it executable by running the following command:

   ```bash
   chmod +x publisher.py
   ```

### **Step 2: Update Package Files**

1. **Update `setup.py`**:
   - Open the `setup.py` file in the root of your package:
  
   ```bash
   cd ~/ros2_ws/src/system
   gedit setup.py
   ```

   - Modify the `entry_points` section to include the new script:

   ```python
   entry_points={
       'console_scripts': [
           'publisher = system.scripts.publisher:main',
       ],
   },
   ```
   - Also modify the `packages` field to the following:
   ```bash
   packages=[package_name, package_name + '.scripts'],
   ```

2. **Rebuild the Workspace**:
   - Navigate back to the workspace root and rebuild:

   ```bash
   cd ~/ros2_ws
   colcon build
   ```
   **If you get a warning message** like the following:
   ```bash
   Starting >>> system
   --- stderr: system           
   package init file 'system/scripts/__init__.py' not found (or not a regular file)
   ---
   Finished <<< system [0.54s]

   Summary: 1 package finished [0.69s]
   1 package had stderr output: system
   ```
   then run the following few commands to add the `__init__.py` file into the scripts folder:
   ```bash
   touch ~/ros2_ws/src/system/system/scripts/__init__.py
   ```
  This should resolve the issue and you can run the `colcon build` command once more to complete the build of the package.
  
4. **Source the Workspace**:
   - Source the setup file to make sure the new script is available:

   ```bash
   source install/setup.bash
   ```

### **Step 3: Run the Node**

1. **Run the Image Publisher Node**:
   - Now, you can run the node to start publishing images from the directory:

   ```bash
   ros2 run system publisher
   ```

   - You should see the following output for now:

   ```bash
   [INFO] [X.X] [mqtt_to_ros_publisher]: Subscribed to MQTT topic: camera/images
   ```

---

# Create a Subscriber Node
---
1. **Navigate to Your Package Directory**:
   - Go to the directory where your package is located:

   ```bash
   cd ~/ros2_ws_test/src/image_processor_test
   ```

2. **Create a Python Script for the Subscriber**:
   - Inside the `scripts` directory, create a new Python script named `image_subscriber.py`:

   ```bash
   cd image_processor_test/scripts
   touch image_subscriber.py
   ```

3. **Write the Subscriber Node Script**:
   - Open the `image_subscriber.py` file with a text editor:

   ```bash
   gedit image_subscriber.py
   ```

   - Add the following code to create a simple subscriber node that listens to the image topic and processes each incoming image:

   ```python
   #!/usr/bin/env python3

   import rclpy
   from rclpy.node import Node
   from sensor_msgs.msg import Image
   from cv_bridge import CvBridge
   import cv2

   class ImageSubscriber(Node):
       def __init__(self):
           super().__init__('image_subscriber')
           self.subscription = self.create_subscription(
               Image,
               'image_topic',
               self.listener_callback,
               10)
           self.subscription  
           self.bridge = CvBridge()

       def listener_callback(self, msg):
           self.get_logger().info('Receiving image')
           cv_image = self.bridge.imgmsg_to_cv2(msg, "bgr8")

           cv2.imshow("Received Image", cv_image)
           cv2.waitKey(1)

   def main(args=None):
       rclpy.init(args=args)
       image_subscriber = ImageSubscriber()
       rclpy.spin(image_subscriber)
       image_subscriber.destroy_node()
       rclpy.shutdown()

   if __name__ == '__main__':
       main()
   ```

4. **Make the Script Executable**:
   - After saving the file, make it executable:

   ```bash
   chmod +x image_subscriber.py
   ```

5. **Update `setup.py`**:
   - Open the `setup.py` file and add the subscriber node to the `entry_points` section:
  
   ```bash
   cd ~/ros2_ws_test/src/image_processor_test
   gedit setup.py
   ```
   
   ```python
   entry_points={
       'console_scripts': [
           'image_publisher = image_processor_test.scripts.image_publisher:main',
           'image_subscriber = image_processor_test.scripts.image_subscriber:main',
       ],
   },
   ```

6. **Rebuild the Workspace**:
   - Rebuild the workspace to include the new script:

   ```bash
   cd ~/ros2_ws_test
   colcon build --packages-select image_processor_test
   ```

7. **Source the Workspace**:
   - After building, source the workspace:

   ```bash
   source install/setup.bash
   ```


## **Run the Image Publisher Node**:
   - In one terminal, start the image publisher node:

   ```bash
   ros2 run image_processor_test image_publisher
   ```

## **Run the Image Subscriber Node**:
   - Open a new terminal, source the workspace, and run the image subscriber node:

   ```bash
   ros2 run image_processor_test image_subscriber
   ```

## **Visualize the Output**:
   - The subscriber node will receive images published by the publisher node and display them using OpenCV. You should see the images appear in a window as they are received. There might be a slight delay in the visualization due to processing time, however, considering this is simply a visualization tool this should not be an issue going forward.
